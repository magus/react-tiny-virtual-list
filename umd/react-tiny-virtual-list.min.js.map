{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-tiny-virtual-list.min.js","webpack:///webpack/bootstrap d799832bf312ee2ab78a","webpack:///./src/constants.js","webpack:///./src/index.js","webpack:///./src/SizeAndPositionManager.js","webpack:///./src/animateScroll.js","webpack:///external {\"root\":\"PropTypes\",\"commonjs2\":\"prop-types\",\"commonjs\":\"prop-types\",\"amd\":\"prop-types\"}","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_4__","__WEBPACK_EXTERNAL_MODULE_5__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","ALIGN_START","ALIGN_CENTER","ALIGN_END","DIRECTION_VERTICAL","scrollProp","sizeProp","positionProp","_scrollProp","_sizeProp","_positionProp","DIRECTION_HORIZONTAL","_objectWithoutProperties","obj","keys","target","indexOf","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","__proto__","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","__WEBPACK_IMPORTED_MODULE_1_prop_types__","__WEBPACK_IMPORTED_MODULE_2__animateScroll__","__WEBPACK_IMPORTED_MODULE_3__SizeAndPositionManager__","__WEBPACK_IMPORTED_MODULE_4__constants__","VirtualList","_class","_temp2","_extends","assign","arguments","length","source","key","STYLE_WRAPPER","overflow","willChange","WebkitOverflowScrolling","STYLE_INNER","position","width","minHeight","STYLE_ITEM","left","_PureComponent","_temp","_this","_ret","_len","args","Array","_key","apply","concat","sizeAndPositionManager","itemCount","props","itemSizeGetter","_ref","index","getSize","estimatedItemSize","getEstimatedItemSize","state","offset","scrollOffset","scrollToIndex","getOffsetForIndex","pauseScroll","_styleCache","_getRef","node","rootNode","handleScroll","e","onScroll","getNodeOffset","setState","handleWheel","size","getTotalSize","height","deltaY","lastScroll","cancel","componentDidMount","_props","scrollTo","componentWillReceiveProps","nextProps","_props2","itemSize","scrollToAlignment","scrollPropsHaveChanged","itemPropsHaveChanged","updateConfig","recomputeSizes","setOffset","componentDidUpdate","nextState","undefined","setPauseScroll","pause","scrollDirection","_props3","animate","animationDuration","getUpdatedOffsetForIndex","align","containerSize","targetIndex","isArray","getStyle","_extends2","style","_sizeAndPositionManag","getSizeAndPositionForIndex","transform","startIndex","resetItem","render","_extends3","_props4","overscanCount","renderItem","displayBottomUpwards","_sizeAndPositionManag2","getVisibleRange","start","stop","totalSize","wrapperStyle","innerStyle","items","push","maxHeight","transition","a","createElement","ref","onWheel","defaultProps","__WEBPACK_IMPORTED_MODULE_0__constants__","SizeAndPositionManager","_itemSizeGetter","_itemCount","_estimatedItemSize","_itemSizeAndPositionData","_lastMeasuredIndex","_ref2","getLastMeasuredIndex","Error","lastMeasuredSizeAndPosition","getSizeAndPositionOfLastMeasuredItem","isNaN","_ref3","_ref3$align","datum","maxOffset","minOffset","idealOffset","Math","max","min","_ref4","_findNearestItem","_binarySearch","_ref5","low","high","middle","currentOffset","floor","_exponentialSearch","_ref6","interval","lastMeasuredIndex","linear","t","b","animateScroll","element","to","duration","timing","scrollTop","change","animationStart","Date","animating","lastpos","promise","Promise","resolve","reject","finish","rAF","now","val","info","then","bind","_typeof","Symbol","iterator","window","requestAnimationFrame","callback","setTimeout"],"mappings":"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","file":"react-tiny-virtual-list.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"prop-types\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"prop-types\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"VirtualList\"] = factory(require(\"prop-types\"), require(\"react\"));\n\telse\n\t\troot[\"VirtualList\"] = factory(root[\"PropTypes\"], root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"prop-types\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"prop-types\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"VirtualList\"] = factory(require(\"prop-types\"), require(\"react\"));\n\telse\n\t\troot[\"VirtualList\"] = factory(root[\"PropTypes\"], root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 6);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return ALIGN_START; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return ALIGN_CENTER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return ALIGN_END; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return DIRECTION_VERTICAL; });\n/* unused harmony export DIRECTION_HORIZONTAL */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return scrollProp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return sizeProp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return positionProp; });\nvar _scrollProp, _sizeProp, _positionProp;\n\nvar ALIGN_START = 'start';\nvar ALIGN_CENTER = 'center';\nvar ALIGN_END = 'end';\nvar DIRECTION_VERTICAL = 'vertical';\nvar DIRECTION_HORIZONTAL = 'horizontal';\n\nvar scrollProp = (_scrollProp = {}, _scrollProp[DIRECTION_VERTICAL] = 'scrollTop', _scrollProp[DIRECTION_HORIZONTAL] = 'scrollLeft', _scrollProp);\nvar sizeProp = (_sizeProp = {}, _sizeProp[DIRECTION_VERTICAL] = 'height', _sizeProp[DIRECTION_HORIZONTAL] = 'width', _sizeProp);\nvar positionProp = (_positionProp = {}, _positionProp[DIRECTION_VERTICAL] = 'translateY', _positionProp[DIRECTION_HORIZONTAL] = 'translateX', _positionProp);\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__animateScroll__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__SizeAndPositionManager__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants__ = __webpack_require__(0);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return VirtualList; });\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _class, _temp2;\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\nvar STYLE_WRAPPER = { overflow: 'auto', willChange: 'transform', WebkitOverflowScrolling: 'touch' };\nvar STYLE_INNER = { position: 'relative', overflow: 'hidden', width: '100%', minHeight: '100%' };\nvar STYLE_ITEM = { position: 'absolute', left: 0, width: '100%' };\n\nvar VirtualList = (_temp2 = _class = function (_PureComponent) {\n  _inherits(VirtualList, _PureComponent);\n\n  function VirtualList() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, VirtualList);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.sizeAndPositionManager = new __WEBPACK_IMPORTED_MODULE_3__SizeAndPositionManager__[\"a\" /* default */]({\n      itemCount: _this.props.itemCount,\n      itemSizeGetter: function itemSizeGetter(_ref) {\n        var index = _ref.index;\n        return _this.getSize(index);\n      },\n      estimatedItemSize: _this.getEstimatedItemSize()\n    }), _this.state = {\n      offset: _this.props.scrollOffset || _this.props.scrollToIndex != null && _this.getOffsetForIndex(_this.props.scrollToIndex) || 0\n    }, _this.pauseScroll = false, _this._styleCache = {}, _this._getRef = function (node) {\n      _this.rootNode = node;\n    }, _this.handleScroll = function (e) {\n      var onScroll = _this.props.onScroll;\n\n      var offset = _this.getNodeOffset();\n\n      _this.setState({ offset: offset });\n\n      if (typeof onScroll === 'function') {\n        onScroll(offset, e);\n      }\n    }, _this.handleWheel = function (e) {\n      var offset = _this.getNodeOffset();\n      var size = _this.sizeAndPositionManager.getTotalSize();\n      var height = _this.props.height;\n\n      if (size < height || offset + height >= size) {\n        _this.pauseScroll = false;\n      } else if (e.deltaY < 0) {\n        // Only pause for scroll up\n        if (_this.lastScroll) _this.lastScroll.cancel();\n        _this.pauseScroll = true;\n      }\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  VirtualList.prototype.componentDidMount = function componentDidMount() {\n    var _props = this.props,\n        scrollOffset = _props.scrollOffset,\n        scrollToIndex = _props.scrollToIndex;\n\n\n    if (scrollOffset != null) {\n      this.scrollTo(scrollOffset);\n    } else if (scrollToIndex != null) {\n      this.scrollTo(this.getOffsetForIndex(scrollToIndex));\n    }\n  };\n\n  VirtualList.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var _props2 = this.props,\n        estimatedItemSize = _props2.estimatedItemSize,\n        itemCount = _props2.itemCount,\n        itemSize = _props2.itemSize,\n        scrollOffset = _props2.scrollOffset,\n        scrollToAlignment = _props2.scrollToAlignment,\n        scrollToIndex = _props2.scrollToIndex;\n\n    var scrollPropsHaveChanged = nextProps.scrollToIndex !== scrollToIndex || nextProps.scrollToAlignment !== scrollToAlignment;\n    var itemPropsHaveChanged = nextProps.itemCount !== itemCount || nextProps.itemSize !== itemSize || nextProps.estimatedItemSize !== estimatedItemSize;\n\n    if (nextProps.itemCount !== itemCount || nextProps.estimatedItemSize !== estimatedItemSize) {\n      this.sizeAndPositionManager.updateConfig({\n        itemCount: nextProps.itemCount,\n        estimatedItemSize: this.getEstimatedItemSize(nextProps)\n      });\n    }\n\n    if (itemPropsHaveChanged) {\n      this.recomputeSizes();\n    }\n\n    if (nextProps.scrollOffset !== scrollOffset) {\n      this.setOffset(nextProps.scrollOffset);\n    } else if (scrollPropsHaveChanged || nextProps.scrollToIndex && itemPropsHaveChanged) {\n      this.setOffset(this.getOffsetForIndex(nextProps.scrollToIndex, nextProps.scrollToAlignment, nextProps.itemCount));\n    }\n  };\n\n  VirtualList.prototype.componentDidUpdate = function componentDidUpdate(nextProps, nextState) {\n    var offset = this.state.offset;\n\n\n    if (nextState.offset !== offset) {\n      this.scrollTo(offset);\n    }\n  };\n\n  VirtualList.prototype.getEstimatedItemSize = function getEstimatedItemSize() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n\n    return props.estimatedItemSize || typeof props.itemSize === \"number\" && props.itemSize || 50;\n  };\n\n  VirtualList.prototype.setOffset = function setOffset(offset) {\n    if (this.pauseScroll) return;\n\n    this.setState({ offset: offset });\n  };\n\n  VirtualList.prototype.setPauseScroll = function setPauseScroll(pause) {\n    this.pauseScroll = pause;\n  };\n\n  VirtualList.prototype.getNodeOffset = function getNodeOffset() {\n    var scrollDirection = this.props.scrollDirection;\n\n    return this.rootNode[__WEBPACK_IMPORTED_MODULE_4__constants__[\"a\" /* scrollProp */][scrollDirection]];\n  };\n\n  VirtualList.prototype.scrollTo = function scrollTo(value) {\n    if (this.pauseScroll) return;\n\n    var _props3 = this.props,\n        scrollDirection = _props3.scrollDirection,\n        animate = _props3.animate,\n        animationDuration = _props3.animationDuration;\n\n    var currentScroll = this.rootNode[__WEBPACK_IMPORTED_MODULE_4__constants__[\"a\" /* scrollProp */][scrollDirection]];\n\n    if (currentScroll === value) return;\n\n    if (!animate) {\n      this.rootNode[__WEBPACK_IMPORTED_MODULE_4__constants__[\"a\" /* scrollProp */][scrollDirection]] = value;\n      return;\n    }\n\n    // Animate scroll offset\n    if (this.lastScroll) this.lastScroll.cancel();\n    this.lastScroll = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__animateScroll__[\"a\" /* default */])(this.rootNode, value, animationDuration);\n  };\n\n  VirtualList.prototype.getOffsetForIndex = function getOffsetForIndex(index) {\n    var scrollToAlignment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props.scrollToAlignment;\n    var itemCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.props.itemCount;\n    var scrollDirection = this.props.scrollDirection;\n\n\n    if (index < 0 || index >= itemCount) {\n      index = 0;\n    }\n\n    return this.sizeAndPositionManager.getUpdatedOffsetForIndex({\n      align: scrollToAlignment,\n      containerSize: this.props[__WEBPACK_IMPORTED_MODULE_4__constants__[\"b\" /* sizeProp */][scrollDirection]],\n      targetIndex: index\n    });\n  };\n\n  VirtualList.prototype.getSize = function getSize(index) {\n    var itemSize = this.props.itemSize;\n\n\n    if (typeof itemSize === 'function') {\n      return itemSize(index);\n    }\n\n    return Array.isArray(itemSize) ? itemSize[index] : itemSize;\n  };\n\n  VirtualList.prototype.getStyle = function getStyle(index) {\n    var _extends2;\n\n    var style = this._styleCache[index];\n    if (style) {\n      return style;\n    }\n\n    var scrollDirection = this.props.scrollDirection;\n\n    var _sizeAndPositionManag = this.sizeAndPositionManager.getSizeAndPositionForIndex(index),\n        size = _sizeAndPositionManag.size,\n        offset = _sizeAndPositionManag.offset;\n\n    return this._styleCache[index] = _extends({}, STYLE_ITEM, (_extends2 = {}, _extends2[__WEBPACK_IMPORTED_MODULE_4__constants__[\"b\" /* sizeProp */][scrollDirection]] = size, _extends2.transform = __WEBPACK_IMPORTED_MODULE_4__constants__[\"c\" /* positionProp */][scrollDirection] + '(' + offset + 'px)', _extends2));\n  };\n\n  VirtualList.prototype.recomputeSizes = function recomputeSizes() {\n    var startIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    this._styleCache = {};\n    this.sizeAndPositionManager.resetItem(startIndex);\n  };\n\n  VirtualList.prototype.render = function render() {\n    var _extends3;\n\n    /* eslint-disable no-unused-vars */\n    var _props4 = this.props,\n        estimatedItemSize = _props4.estimatedItemSize,\n        height = _props4.height,\n        overscanCount = _props4.overscanCount,\n        renderItem = _props4.renderItem,\n        itemCount = _props4.itemCount,\n        itemSize = _props4.itemSize,\n        scrollDirection = _props4.scrollDirection,\n        scrollOffset = _props4.scrollOffset,\n        scrollToIndex = _props4.scrollToIndex,\n        scrollToAlignment = _props4.scrollToAlignment,\n        style = _props4.style,\n        width = _props4.width,\n        displayBottomUpwards = _props4.displayBottomUpwards,\n        animate = _props4.animate,\n        animationDuration = _props4.animationDuration,\n        props = _objectWithoutProperties(_props4, ['estimatedItemSize', 'height', 'overscanCount', 'renderItem', 'itemCount', 'itemSize', 'scrollDirection', 'scrollOffset', 'scrollToIndex', 'scrollToAlignment', 'style', 'width', 'displayBottomUpwards', 'animate', 'animationDuration']);\n\n    var offset = this.state.offset;\n\n    var _sizeAndPositionManag2 = this.sizeAndPositionManager.getVisibleRange({\n      containerSize: this.props[__WEBPACK_IMPORTED_MODULE_4__constants__[\"b\" /* sizeProp */][scrollDirection]],\n      offset: offset,\n      overscanCount: overscanCount\n    }),\n        start = _sizeAndPositionManag2.start,\n        stop = _sizeAndPositionManag2.stop;\n\n    var totalSize = this.sizeAndPositionManager.getTotalSize();\n\n    var wrapperStyle = _extends({}, STYLE_WRAPPER, style, { width: width, height: height });\n    var innerStyle = _extends({}, STYLE_INNER, (_extends3 = {}, _extends3[__WEBPACK_IMPORTED_MODULE_4__constants__[\"b\" /* sizeProp */][scrollDirection]] = totalSize, _extends3));\n\n    var items = [];\n\n    for (var index = start; index <= stop; index++) {\n      items.push(renderItem({\n        index: index,\n        style: this.getStyle(index)\n      }));\n    }\n\n    if (displayBottomUpwards) {\n      wrapperStyle.maxHeight = height;\n      delete wrapperStyle.height;\n\n      innerStyle.minHeight = '0';\n\n      // Transition height up until it maxes out\n      if (animate && totalSize < height) innerStyle.transition = 'height ' + animationDuration / 1000 + 's ease';\n    }\n\n    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\n      'div',\n      _extends({\n        ref: this._getRef\n      }, props, {\n        onScroll: this.handleScroll,\n        onWheel: this.handleWheel,\n        style: wrapperStyle\n      }),\n      __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\n        'div',\n        {\n          style: innerStyle\n        },\n        items\n      )\n    );\n  };\n\n  return VirtualList;\n}(__WEBPACK_IMPORTED_MODULE_0_react__[\"PureComponent\"]), _class.defaultProps = {\n  overscanCount: 3,\n  scrollDirection: __WEBPACK_IMPORTED_MODULE_4__constants__[\"d\" /* DIRECTION_VERTICAL */],\n  width: '100%',\n  animationDuration: 200\n}, _temp2);\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(0);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return SizeAndPositionManager; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* Forked from react-virtualized 💖 */\n\n\nvar SizeAndPositionManager = function () {\n  function SizeAndPositionManager(_ref) {\n    var itemCount = _ref.itemCount,\n        itemSizeGetter = _ref.itemSizeGetter,\n        estimatedItemSize = _ref.estimatedItemSize;\n\n    _classCallCheck(this, SizeAndPositionManager);\n\n    this._itemSizeGetter = itemSizeGetter;\n    this._itemCount = itemCount;\n    this._estimatedItemSize = estimatedItemSize;\n\n    // Cache of size and position data for items, mapped by item index.\n    this._itemSizeAndPositionData = {};\n\n    // Measurements for items up to this index can be trusted; items afterward should be estimated.\n    this._lastMeasuredIndex = -1;\n  }\n\n  SizeAndPositionManager.prototype.updateConfig = function updateConfig(_ref2) {\n    var itemCount = _ref2.itemCount,\n        estimatedItemSize = _ref2.estimatedItemSize;\n\n    this._itemCount = itemCount;\n    this._estimatedItemSize = estimatedItemSize;\n  };\n\n  SizeAndPositionManager.prototype.getLastMeasuredIndex = function getLastMeasuredIndex() {\n    return this._lastMeasuredIndex;\n  };\n\n  /**\n   * This method returns the size and position for the item at the specified index.\n   * It just-in-time calculates (or used cached values) for items leading up to the index.\n   */\n\n\n  SizeAndPositionManager.prototype.getSizeAndPositionForIndex = function getSizeAndPositionForIndex(index) {\n    if (index < 0 || index >= this._itemCount) {\n      throw Error('Requested index ' + index + ' is outside of range 0..' + this._itemCount);\n    }\n\n    if (index > this._lastMeasuredIndex) {\n      var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n      var offset = lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;\n\n      for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {\n        var size = this._itemSizeGetter({ index: i });\n\n        if (size == null || isNaN(size)) {\n          throw Error('Invalid size returned for index ' + i + ' of value ' + size);\n        }\n\n        this._itemSizeAndPositionData[i] = {\n          offset: offset,\n          size: size\n        };\n\n        offset += size;\n      }\n\n      this._lastMeasuredIndex = index;\n    }\n\n    return this._itemSizeAndPositionData[index];\n  };\n\n  SizeAndPositionManager.prototype.getSizeAndPositionOfLastMeasuredItem = function getSizeAndPositionOfLastMeasuredItem() {\n    return this._lastMeasuredIndex >= 0 ? this._itemSizeAndPositionData[this._lastMeasuredIndex] : { offset: 0, size: 0 };\n  };\n\n  /**\n  * Total size of all items being measured.\n  * This value will be completedly estimated initially.\n  * As items as measured the estimate will be updated.\n  */\n\n\n  SizeAndPositionManager.prototype.getTotalSize = function getTotalSize() {\n    var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n\n    return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this._itemCount - this._lastMeasuredIndex - 1) * this._estimatedItemSize;\n  };\n\n  /**\n   * Determines a new offset that ensures a certain item is visible, given the alignment.\n   *\n   * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\n   * @param containerSize Size (width or height) of the container viewport\n   * @return Offset to use to ensure the specified item is visible\n   */\n\n\n  SizeAndPositionManager.prototype.getUpdatedOffsetForIndex = function getUpdatedOffsetForIndex(_ref3) {\n    var _ref3$align = _ref3.align,\n        align = _ref3$align === undefined ? __WEBPACK_IMPORTED_MODULE_0__constants__[\"e\" /* ALIGN_START */] : _ref3$align,\n        containerSize = _ref3.containerSize,\n        targetIndex = _ref3.targetIndex;\n\n    if (containerSize <= 0) {\n      return 0;\n    }\n\n    var datum = this.getSizeAndPositionForIndex(targetIndex);\n    var maxOffset = datum.offset;\n    var minOffset = maxOffset - containerSize + datum.size;\n\n    var idealOffset = void 0;\n\n    switch (align) {\n      case __WEBPACK_IMPORTED_MODULE_0__constants__[\"f\" /* ALIGN_END */]:\n        idealOffset = minOffset;\n        break;\n      case __WEBPACK_IMPORTED_MODULE_0__constants__[\"g\" /* ALIGN_CENTER */]:\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\n        break;\n      default:\n        idealOffset = maxOffset;\n        break;\n    }\n\n    var totalSize = this.getTotalSize();\n\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n  };\n\n  SizeAndPositionManager.prototype.getVisibleRange = function getVisibleRange(_ref4) {\n    var containerSize = _ref4.containerSize,\n        offset = _ref4.offset,\n        overscanCount = _ref4.overscanCount;\n\n    var totalSize = this.getTotalSize();\n\n    if (totalSize === 0) {\n      return {};\n    }\n\n    var maxOffset = offset + containerSize;\n    var start = this._findNearestItem(offset);\n    var stop = start;\n\n    var datum = this.getSizeAndPositionForIndex(start);\n    offset = datum.offset + datum.size;\n\n    while (offset < maxOffset && stop < this._itemCount - 1) {\n      stop++;\n      offset += this.getSizeAndPositionForIndex(stop).size;\n    }\n\n    if (overscanCount) {\n      start = Math.max(0, start - overscanCount);\n      stop = Math.min(stop + overscanCount, this._itemCount - 1);\n    }\n\n    return {\n      start: start,\n      stop: stop\n    };\n  };\n\n  /**\n   * Clear all cached values for items after the specified index.\n   * This method should be called for any item that has changed its size.\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n   */\n\n\n  SizeAndPositionManager.prototype.resetItem = function resetItem(index) {\n    this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\n  };\n\n  SizeAndPositionManager.prototype._binarySearch = function _binarySearch(_ref5) {\n    var low = _ref5.low,\n        high = _ref5.high,\n        offset = _ref5.offset;\n\n    var middle = void 0;\n    var currentOffset = void 0;\n\n    while (low <= high) {\n      middle = low + Math.floor((high - low) / 2);\n      currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n\n      if (currentOffset === offset) {\n        return middle;\n      } else if (currentOffset < offset) {\n        low = middle + 1;\n      } else if (currentOffset > offset) {\n        high = middle - 1;\n      }\n    }\n\n    if (low > 0) {\n      return low - 1;\n    }\n  };\n\n  SizeAndPositionManager.prototype._exponentialSearch = function _exponentialSearch(_ref6) {\n    var index = _ref6.index,\n        offset = _ref6.offset;\n\n    var interval = 1;\n\n    while (index < this._itemCount && this.getSizeAndPositionForIndex(index).offset < offset) {\n      index += interval;\n      interval *= 2;\n    }\n\n    return this._binarySearch({\n      high: Math.min(index, this._itemCount - 1),\n      low: Math.floor(index / 2),\n      offset: offset\n    });\n  };\n\n  /**\n   * Searches for the item (index) nearest the specified offset.\n   *\n   * If no exact match is found the next lowest item index will be returned.\n   * This allows partially visible items (with offsets just before/above the fold) to be visible.\n   */\n\n\n  SizeAndPositionManager.prototype._findNearestItem = function _findNearestItem(offset) {\n    if (isNaN(offset)) {\n      throw Error('Invalid offset ' + offset + ' specified');\n    }\n\n    // Our search algorithms find the nearest match at or below the specified offset.\n    // So make sure the offset is at least 0 or no match will be found.\n    offset = Math.max(0, offset);\n\n    var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n    var lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);\n\n    if (lastMeasuredSizeAndPosition.offset >= offset) {\n      // If we've already measured items within this range just use a binary search as it's faster.\n      return this._binarySearch({\n        high: lastMeasuredIndex,\n        low: 0,\n        offset: offset\n      });\n    } else {\n      // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n      // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n      // The overall complexity for this approach is O(log n).\n      return this._exponentialSearch({\n        index: lastMeasuredIndex,\n        offset: offset\n      });\n    }\n  };\n\n  return SizeAndPositionManager;\n}();\n\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = animateScroll;\n/* unused harmony export animateScrollQuad */\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar rAF = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' ? window.requestAnimationFrame : function (callback) {\n  return setTimeout(callback, 1000 / 60);\n};\n\nfunction easeInOutQuad(t, b, c, d) {\n  t /= d / 2;\n  if (t < 1) return c / 2 * t * t + b;\n  t--;\n  return -c / 2 * (t * (t - 2) - 1) + b;\n}\n\nfunction linear(t, b, c, d) {\n  var p = t / d;\n\n  if (p > 1) return b + c;\n\n  return b + p * c;\n}\n\nfunction animateScroll(element, to, duration) {\n  var timing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : linear;\n\n  var start = element.scrollTop;\n  var change = to - start;\n  var animationStart = +new Date();\n\n  var animating = true;\n  var lastpos = start;\n\n  var promise = new Promise(function (resolve, reject) {\n    function finish() {\n      animating = false;\n      resolve();\n    }\n\n    function animateScroll() {\n      if (!animating) return;\n\n      rAF(animateScroll);\n\n      var now = +new Date();\n      var val = Math.floor(timing(now - animationStart, start, change, duration));\n\n      if (lastpos === val) return;\n\n      lastpos = val;\n      element.scrollTop = val;\n\n      if (element.scrollTop === to) {\n        finish();\n      }\n\n      if (now > animationStart + duration) {\n        element.scrollTop = to;\n        finish();\n      }\n\n      if (now > animationStart + duration) {\n        element.scrollTop = to;\n        finish();\n      }\n    }\n\n    rAF(animateScroll);\n  });\n\n  return {\n    info: function info() {\n      return { animating: animating, lastpos: lastpos, to: to };\n    },\n    then: promise.then.bind(promise),\n    cancel: function cancel() {\n      animating = false;\n    }\n  };\n};\n\nvar animateScrollQuad = function animateScrollQuad(element, to, duration) {\n  return animateScroll(element, to, duration, easeInOutQuad);\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// react-tiny-virtual-list.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d799832bf312ee2ab78a","export const ALIGN_START = 'start';\nexport const ALIGN_CENTER = 'center';\nexport const ALIGN_END = 'end';\nexport const DIRECTION_VERTICAL = 'vertical';\nexport const DIRECTION_HORIZONTAL = 'horizontal';\n\nexport const scrollProp = {\n  [DIRECTION_VERTICAL]: 'scrollTop',\n  [DIRECTION_HORIZONTAL]: 'scrollLeft',\n};\nexport const sizeProp = {\n  [DIRECTION_VERTICAL]: 'height',\n  [DIRECTION_HORIZONTAL]: 'width',\n};\nexport const positionProp = {\n  [DIRECTION_VERTICAL]: 'translateY',\n  [DIRECTION_HORIZONTAL]: 'translateX',\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/constants.js","import React, {PureComponent} from 'react';\nimport PropTypes from 'prop-types';\nimport animateScroll from './animateScroll';\nimport SizeAndPositionManager from './SizeAndPositionManager';\nimport {\n  ALIGN_CENTER,\n  ALIGN_END,\n  ALIGN_START,\n  DIRECTION_VERTICAL,\n  DIRECTION_HORIZONTAL,\n  positionProp,\n  scrollProp,\n  sizeProp,\n} from './constants';\n\nconst STYLE_WRAPPER = {overflow: 'auto', willChange: 'transform', WebkitOverflowScrolling: 'touch'};\nconst STYLE_INNER = {position: 'relative', overflow: 'hidden', width: '100%', minHeight: '100%'};\nconst STYLE_ITEM = {position: 'absolute', left: 0, width: '100%'};\n\nexport default class VirtualList extends PureComponent {\n  static defaultProps = {\n    overscanCount: 3,\n    scrollDirection: DIRECTION_VERTICAL,\n    width: '100%',\n    animationDuration: 200,\n  };\n\n  static propTypes = {\n    estimatedItemSize: PropTypes.number,\n    height: PropTypes.number.isRequired,\n    itemCount: PropTypes.number.isRequired,\n    itemSize: PropTypes.oneOfType([PropTypes.number, PropTypes.array, PropTypes.func]).isRequired,\n    overscanCount: PropTypes.number,\n    renderItem: PropTypes.func.isRequired,\n    scrollOffset: PropTypes.number,\n    scrollToIndex: PropTypes.number,\n    scrollToAlignment: PropTypes.oneOf([ALIGN_START, ALIGN_CENTER, ALIGN_END]),\n    scrollDirection: PropTypes.oneOf([DIRECTION_HORIZONTAL, DIRECTION_VERTICAL]).isRequired,\n    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    displayBottomUpwards: PropTypes.bool,\n    animate: PropTypes.bool,\n    animationDuration: PropTypes.number,\n  }\n\n  sizeAndPositionManager = new SizeAndPositionManager({\n    itemCount: this.props.itemCount,\n    itemSizeGetter: ({index}) => this.getSize(index),\n    estimatedItemSize: this.getEstimatedItemSize(),\n  });\n\n  state = {\n    offset: (\n      this.props.scrollOffset ||\n      this.props.scrollToIndex != null && this.getOffsetForIndex(this.props.scrollToIndex) ||\n      0\n    ),\n  };\n\n  pauseScroll = false;\n\n  _styleCache = {};\n\n  _getRef = node => {\n    this.rootNode = node;\n  };\n\n  componentDidMount() {\n    const {scrollOffset, scrollToIndex} = this.props;\n\n    if (scrollOffset != null) {\n      this.scrollTo(scrollOffset);\n    } else if (scrollToIndex != null) {\n      this.scrollTo(this.getOffsetForIndex(scrollToIndex));\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    const {\n      estimatedItemSize,\n      itemCount,\n      itemSize,\n      scrollOffset,\n      scrollToAlignment,\n      scrollToIndex,\n    } = this.props;\n    const scrollPropsHaveChanged = (\n      nextProps.scrollToIndex !== scrollToIndex ||\n      nextProps.scrollToAlignment !== scrollToAlignment\n    );\n    const itemPropsHaveChanged = (\n      nextProps.itemCount !== itemCount ||\n      nextProps.itemSize !== itemSize ||\n      nextProps.estimatedItemSize !== estimatedItemSize\n    );\n\n    if (\n      nextProps.itemCount !== itemCount ||\n      nextProps.estimatedItemSize !== estimatedItemSize\n    ) {\n      this.sizeAndPositionManager.updateConfig({\n        itemCount: nextProps.itemCount,\n        estimatedItemSize: this.getEstimatedItemSize(nextProps),\n      });\n    }\n\n    if (itemPropsHaveChanged) {\n      this.recomputeSizes();\n    }\n\n    if (nextProps.scrollOffset !== scrollOffset) {\n      this.setOffset(nextProps.scrollOffset);\n    } else if (\n      scrollPropsHaveChanged ||\n      nextProps.scrollToIndex && itemPropsHaveChanged\n    ) {\n      this.setOffset(this.getOffsetForIndex(nextProps.scrollToIndex, nextProps.scrollToAlignment, nextProps.itemCount));\n    }\n  }\n\n  componentDidUpdate(nextProps, nextState) {\n    const {offset} = this.state;\n\n    if (nextState.offset !== offset) {\n      this.scrollTo(offset);\n    }\n  }\n\n  handleScroll = e => {\n    const {onScroll} = this.props;\n    const offset = this.getNodeOffset();\n\n    this.setState({offset});\n\n    if (typeof onScroll === 'function') {\n      onScroll(offset, e);\n    }\n  };\n\n  handleWheel = e => {\n    const offset = this.getNodeOffset();\n    const size = this.sizeAndPositionManager.getTotalSize();\n    const height = this.props.height;\n\n    if (size < height || offset + height >= size) {\n      this.pauseScroll = false;\n    } else if (e.deltaY < 0) {\n      // Only pause for scroll up\n      if (this.lastScroll) this.lastScroll.cancel();\n      this.pauseScroll = true;\n    }\n  };\n\n  getEstimatedItemSize(props = this.props) {\n    return props.estimatedItemSize || typeof props.itemSize === \"number\" && props.itemSize || 50;\n  }\n\n  setOffset(offset) {\n    if (this.pauseScroll) return;\n\n    this.setState({ offset: offset });\n  }\n\n  setPauseScroll(pause) {\n    this.pauseScroll = pause;\n  }\n\n  getNodeOffset() {\n    const {scrollDirection} = this.props;\n    return this.rootNode[scrollProp[scrollDirection]];\n  }\n\n  scrollTo(value) {\n    if (this.pauseScroll) return;\n\n    const { scrollDirection, animate, animationDuration } = this.props;\n    const currentScroll = this.rootNode[scrollProp[scrollDirection]];\n\n    if (currentScroll === value) return;\n\n    if (!animate) {\n      this.rootNode[scrollProp[scrollDirection]] = value;\n      return;\n    }\n\n    // Animate scroll offset\n    if (this.lastScroll) this.lastScroll.cancel();\n    this.lastScroll = animateScroll(this.rootNode, value, animationDuration);\n\n  }\n\n  getOffsetForIndex(index, scrollToAlignment = this.props.scrollToAlignment, itemCount = this.props.itemCount) {\n    const {scrollDirection} = this.props;\n\n    if (index < 0 || index >= itemCount) {\n      index = 0;\n    }\n\n    return this.sizeAndPositionManager.getUpdatedOffsetForIndex({\n      align: scrollToAlignment,\n      containerSize: this.props[sizeProp[scrollDirection]],\n      targetIndex: index,\n    });\n  }\n\n  getSize(index) {\n    const {itemSize} = this.props;\n\n    if (typeof itemSize === 'function') { return itemSize(index); }\n\n    return Array.isArray(itemSize) ? itemSize[index] : itemSize;\n  }\n\n  getStyle(index) {\n    const style = this._styleCache[index];\n    if (style) { return style; }\n\n    const {scrollDirection} = this.props;\n    const {size, offset} = this.sizeAndPositionManager.getSizeAndPositionForIndex(index);\n\n    return this._styleCache[index] = {\n      ...STYLE_ITEM,\n      [sizeProp[scrollDirection]]: size,\n      transform: `${positionProp[scrollDirection]}(${offset}px)`,\n    };\n  }\n\n  recomputeSizes(startIndex = 0) {\n    this._styleCache = {};\n    this.sizeAndPositionManager.resetItem(startIndex);\n  }\n\n  render() {\n    /* eslint-disable no-unused-vars */\n    const {\n      estimatedItemSize,\n      height,\n      overscanCount,\n      renderItem,\n      itemCount,\n      itemSize,\n      scrollDirection,\n      scrollOffset,\n      scrollToIndex,\n      scrollToAlignment,\n      style,\n      width,\n      displayBottomUpwards,\n      animate,\n      animationDuration,\n      ...props\n    } = this.props;\n    const {offset} = this.state;\n    const {start, stop} = this.sizeAndPositionManager.getVisibleRange({\n      containerSize: this.props[sizeProp[scrollDirection]],\n      offset,\n      overscanCount,\n    });\n\n    const totalSize = this.sizeAndPositionManager.getTotalSize();\n\n    const wrapperStyle = {...STYLE_WRAPPER, ...style, width, height };\n    const innerStyle = {\n      ...STYLE_INNER,\n      [sizeProp[scrollDirection]]: totalSize,\n    };\n\n    const items = [];\n\n    for (let index = start; index <= stop; index++) {\n      items.push(renderItem({\n        index,\n        style: this.getStyle(index),\n      }));\n    }\n\n    if (displayBottomUpwards) {\n      wrapperStyle.maxHeight = height;\n      delete wrapperStyle.height;\n\n      innerStyle.minHeight = '0';\n\n      // Transition height up until it maxes out\n      if (animate && totalSize < height) innerStyle.transition = `height ${animationDuration / 1000}s ease`;\n    }\n\n    return (\n      <div\n        ref={this._getRef}\n        {...props}\n        onScroll={this.handleScroll}\n        onWheel={this.handleWheel}\n        style={wrapperStyle}\n      >\n        <div\n          style={innerStyle}\n        >\n          {items}\n        </div>\n      </div>\n    );\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/* Forked from react-virtualized 💖 */\nimport {ALIGN_START, ALIGN_END, ALIGN_CENTER} from './constants';\n\nexport default class SizeAndPositionManager {\n  constructor({\n    itemCount,\n    itemSizeGetter,\n    estimatedItemSize,\n  }) {\n    this._itemSizeGetter = itemSizeGetter;\n    this._itemCount = itemCount;\n    this._estimatedItemSize = estimatedItemSize;\n\n    // Cache of size and position data for items, mapped by item index.\n    this._itemSizeAndPositionData = {};\n\n    // Measurements for items up to this index can be trusted; items afterward should be estimated.\n    this._lastMeasuredIndex = -1;\n  }\n\n  updateConfig({\n    itemCount,\n    estimatedItemSize,\n  }) {\n    this._itemCount = itemCount;\n    this._estimatedItemSize = estimatedItemSize;\n  }\n\n  getLastMeasuredIndex() {\n    return this._lastMeasuredIndex;\n  }\n\n  /**\n   * This method returns the size and position for the item at the specified index.\n   * It just-in-time calculates (or used cached values) for items leading up to the index.\n   */\n  getSizeAndPositionForIndex(index) {\n    if (index < 0 || index >= this._itemCount) {\n      throw Error(`Requested index ${index} is outside of range 0..${this._itemCount}`);\n    }\n\n    if (index > this._lastMeasuredIndex) {\n      let lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n      let offset = lastMeasuredSizeAndPosition.offset +\n        lastMeasuredSizeAndPosition.size;\n\n      for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {\n        let size = this._itemSizeGetter({index: i});\n\n        if (size == null || isNaN(size)) {\n          throw Error(`Invalid size returned for index ${i} of value ${size}`);\n        }\n\n        this._itemSizeAndPositionData[i] = {\n          offset,\n          size,\n        };\n\n        offset += size;\n      }\n\n      this._lastMeasuredIndex = index;\n    }\n\n    return this._itemSizeAndPositionData[index];\n  }\n\n  getSizeAndPositionOfLastMeasuredItem() {\n    return this._lastMeasuredIndex >= 0\n      ? this._itemSizeAndPositionData[this._lastMeasuredIndex]\n      : {offset: 0, size: 0};\n  }\n\n  /**\n  * Total size of all items being measured.\n  * This value will be completedly estimated initially.\n  * As items as measured the estimate will be updated.\n  */\n  getTotalSize() {\n    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n\n    return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this._itemCount - this._lastMeasuredIndex - 1) * this._estimatedItemSize;\n  }\n\n  /**\n   * Determines a new offset that ensures a certain item is visible, given the alignment.\n   *\n   * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\n   * @param containerSize Size (width or height) of the container viewport\n   * @return Offset to use to ensure the specified item is visible\n   */\n  getUpdatedOffsetForIndex({\n    align = ALIGN_START,\n    containerSize,\n    targetIndex,\n  }) {\n    if (containerSize <= 0) {\n      return 0;\n    }\n\n    const datum = this.getSizeAndPositionForIndex(targetIndex);\n    const maxOffset = datum.offset;\n    const minOffset = maxOffset - containerSize + datum.size;\n\n    let idealOffset;\n\n    switch (align) {\n      case ALIGN_END:\n        idealOffset = minOffset;\n        break;\n      case ALIGN_CENTER:\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\n        break;\n      default:\n        idealOffset = maxOffset;\n        break;\n    }\n\n    const totalSize = this.getTotalSize();\n\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n  }\n\n  getVisibleRange({containerSize, offset, overscanCount}) {\n    const totalSize = this.getTotalSize();\n\n    if (totalSize === 0) { return {}; }\n\n    const maxOffset = offset + containerSize;\n    let start = this._findNearestItem(offset);\n    let stop = start;\n\n    const datum = this.getSizeAndPositionForIndex(start);\n    offset = datum.offset + datum.size;\n\n    while (offset < maxOffset && stop < this._itemCount - 1) {\n      stop++;\n      offset += this.getSizeAndPositionForIndex(stop).size;\n    }\n\n    if (overscanCount) {\n      start = Math.max(0, start - overscanCount);\n      stop = Math.min(stop + overscanCount, this._itemCount - 1);\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n\n  /**\n   * Clear all cached values for items after the specified index.\n   * This method should be called for any item that has changed its size.\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n   */\n  resetItem(index) {\n    this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\n  }\n\n  _binarySearch({low, high, offset}) {\n    let middle;\n    let currentOffset;\n\n    while (low <= high) {\n      middle = low + Math.floor((high - low) / 2);\n      currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n\n      if (currentOffset === offset) {\n        return middle;\n      } else if (currentOffset < offset) {\n        low = middle + 1;\n      } else if (currentOffset > offset) {\n        high = middle - 1;\n      }\n    }\n\n    if (low > 0) {\n      return low - 1;\n    }\n  }\n\n  _exponentialSearch({index, offset}) {\n    let interval = 1;\n\n    while (\n      index < this._itemCount &&\n      this.getSizeAndPositionForIndex(index).offset < offset\n    ) {\n      index += interval;\n      interval *= 2;\n    }\n\n    return this._binarySearch({\n      high: Math.min(index, this._itemCount - 1),\n      low: Math.floor(index / 2),\n      offset,\n    });\n  }\n\n  /**\n   * Searches for the item (index) nearest the specified offset.\n   *\n   * If no exact match is found the next lowest item index will be returned.\n   * This allows partially visible items (with offsets just before/above the fold) to be visible.\n   */\n  _findNearestItem(offset) {\n    if (isNaN(offset)) {\n      throw Error(`Invalid offset ${offset} specified`);\n    }\n\n    // Our search algorithms find the nearest match at or below the specified offset.\n    // So make sure the offset is at least 0 or no match will be found.\n    offset = Math.max(0, offset);\n\n    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n    const lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);\n\n    if (lastMeasuredSizeAndPosition.offset >= offset) {\n      // If we've already measured items within this range just use a binary search as it's faster.\n      return this._binarySearch({\n        high: lastMeasuredIndex,\n        low: 0,\n        offset,\n      });\n    } else {\n      // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n      // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n      // The overall complexity for this approach is O(log n).\n      return this._exponentialSearch({\n        index: lastMeasuredIndex,\n        offset,\n      });\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/SizeAndPositionManager.js","const rAF = (\n  typeof(window) === 'object'\n  ? window.requestAnimationFrame\n  : callback => setTimeout(callback, 1000 / 60)\n);\n\nfunction easeInOutQuad(t, b, c, d) {\n  t /= d / 2;\n  if (t < 1) return c / 2 * t * t + b;\n  t--;\n  return -c / 2 * (t * (t - 2) - 1) + b;\n}\n\nfunction linear(t, b, c, d) {\n  let p = t / d;\n\n  if (p > 1) return b + c;\n\n  return b + (p * c);\n}\n\nexport default function animateScroll(element, to, duration, timing = linear) {\n  const start = element.scrollTop;\n  const change = to - start;\n  const animationStart = +new Date();\n\n  let animating = true;\n  let lastpos = start;\n\n  const promise = new Promise((resolve, reject) => {\n    function finish() {\n      animating = false;\n      resolve();\n    }\n\n    function animateScroll() {\n      if (!animating) return;\n\n      rAF(animateScroll);\n\n      const now = +new Date();\n      const val = Math.floor(timing(now - animationStart, start, change, duration));\n\n      if (lastpos === val) return;\n\n      lastpos = val;\n      element.scrollTop = val;\n\n      if (element.scrollTop === to) {\n        finish();\n      }\n\n      if (now > animationStart + duration) {\n        element.scrollTop = to;\n        finish();\n      }\n\n      if (now > animationStart + duration) {\n        element.scrollTop = to;\n        finish();\n      }\n    }\n\n    rAF(animateScroll);\n  });\n\n  return {\n    info: () => ({ animating, lastpos, to }),\n    then: promise.then.bind(promise),\n    cancel: () => {\n      animating = false;\n    },\n  };\n};\n\nexport const animateScrollQuad = (element, to, duration) => animateScroll(element, to, duration, easeInOutQuad);\n\n\n\n// WEBPACK FOOTER //\n// ./src/animateScroll.js","module.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"PropTypes\",\"commonjs2\":\"prop-types\",\"commonjs\":\"prop-types\",\"amd\":\"prop-types\"}\n// module id = 4\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}